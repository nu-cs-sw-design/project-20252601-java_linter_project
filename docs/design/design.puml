@startuml

package "Presentation Layer" {

    class Application {
        - ui: UserInterface
        - linter: Linter
        + Application(ui: UserInterface)
        + run(): void
        + {static} main(args: String[]): void
    }

    interface UserInterface {
        + start(): void
        + promptForClassInputType(): ClassInputType
        + promptForDirectoryOrFiles(): List<String>
        + promptForFullyQualifiedNames(): List<String>
        + promptForChecks(available: List<CheckType>): List<CheckType>
        + promptForLLMProvider(available: List<LLMProviderType>): LLMProviderType
        + promptForApiKey(provider: LLMProviderType): String
        + displayError(message: String): void
    }

    class CLIUserInterface {
        - scanner: Scanner
        + CLIUserInterface()
        + start(): void
        + promptForClassInputType(): ClassInputType
        + promptForDirectoryOrFiles(): List<String>
        + promptForFullyQualifiedNames(): List<String>
        + promptForChecks(available: List<CheckType>): List<CheckType>
        + promptForLLMProvider(available: List<LLMProviderType>): LLMProviderType
        + promptForApiKey(provider: LLMProviderType): String
        + displayError(message: String): void
        + onLintResult(result: LintResult): void
        + onCheckPassed(checkName: String, classCount: int): void
        + onAnalysisComplete(totalIssues: int, classCount: int): void
    }
}

package "Domain Layer" {

    class Linter {
        - classAnalyzer: ClassAnalyzer
        - dependencyGraph: DependencyGraph
        - observers: List<LintResultObserver>
        - llmService: LLMService
        - {static} MAX_ARGUMENTS: int
        + Linter()
        + addObserver(observer: LintResultObserver): void
        + removeObserver(observer: LintResultObserver): void
        + analyzeFromPaths(filePaths: List<String>, selectedChecks: List<CheckType>): void
        + analyzeFromNames(classNames: List<String>, selectedChecks: List<CheckType>): void
        + registerLLMService(llmService: LLMService): void
        - runChecks(classDataList: List<ClassData>, selectedChecks: List<CheckType>): void
        - createCheck(type: CheckType): LintCheck
        - notifyObservers(result: LintResult): void
        - notifyPass(checkName: String, classCount: int): void
        - notifyAnalysisComplete(totalIssues: int, classCount: int): void
    }

    class LLMServiceFactory {
        + createService(type: LLMProviderType, apiKey: String): LLMService
        + getAvailableProviders(): List<LLMProviderType>
    }

    package "checks" {
        abstract class LintCheck {
            # checkType: CheckType
            # name: String
            # description: String
            + LintCheck(checkType: CheckType, name: String, description: String)
            + getName(): String
            + getDescription(): String
            + getCheckType(): CheckType
            + {abstract} check(classData: ClassData): List<LintResult>
            # createResult(severity: Severity, message: String, location: String): LintResult
        }

        class TooManyArgumentsCheck {
            - maxArguments: int
            + TooManyArgumentsCheck(maxArguments: int)
            + check(classData: ClassData): List<LintResult>
        }

        class ConcreteDependencyCheck {
            - dependencyGraph: DependencyGraph
            + ConcreteDependencyCheck(dependencyGraph: DependencyGraph)
            + check(classData: ClassData): List<LintResult>
        }

        class PublicNonFinalFieldCheck {
            + PublicNonFinalFieldCheck()
            + check(classData: ClassData): List<LintResult>
        }

        class UnusedPrivateMethodCheck {
            + UnusedPrivateMethodCheck()
            + check(classData: ClassData): List<LintResult>
            - isMethodCalled(targetMethod: MethodData, allMethods: List<MethodData>): boolean
        }

        class MethodNameAppropriatenessCheck {
            - llmService: LLMService
            + MethodNameAppropriatenessCheck(llmService: LLMService)
            + check(classData: ClassData): List<LintResult>
            - buildPrompt(method: MethodData): String
        }

        class CircularDependencyCheck {
            - dependencyGraph: DependencyGraph
            + CircularDependencyCheck(dependencyGraph: DependencyGraph)
            + check(classData: ClassData): List<LintResult>
            + detectAllCycles(): List<LintResult>
        }

        enum CheckType {
            TOO_MANY_ARGUMENTS
            PUBLIC_NON_FINAL_FIELD
            UNUSED_PRIVATE_METHOD
            METHOD_NAME_APPROPRIATENESS
            CIRCULAR_DEPENDENCY
            CONCRETE_DEPENDENCY
        }
    }

    package "lint_result" {
        class LintResult {
            - severity: Severity
            - message: String
            - location: String
            - checkName: String
            - suggestion: String
            + LintResult(severity: Severity, message: String, location: String, checkName: String)
            + getSeverity(): Severity
            + getMessage(): String
            + getLocation(): String
            + getCheckName(): String
            + getSuggestion(): String
            + setSuggestion(suggestion: String): void
            + toString(): String
        }

        interface LintResultObserver {
            + onLintResult(result: LintResult): void
            + onCheckPassed(checkName: String, classCount: int): void
            + onAnalysisComplete(totalIssues: int, classCount: int): void
        }

        enum Severity {
            INFO
            WARNING
            ERROR
            CRITICAL
        }
    }

    package "internal_model" {
        class ClassData {
            - className: String
            - superName: String
            - interfaces: List<String>
            - methods: List<MethodData>
            - fields: List<FieldData>
            + ClassData(className: String)
            + getClassName(): String
            + getSuperName(): String
            + setSuperName(superName: String): void
            + getInterfaces(): List<String>
            + setInterfaces(interfaces: List<String>): void
            + getMethods(): List<MethodData>
            + getFields(): List<FieldData>
            + setMethods(methods: List<MethodData>): void
            + setFields(fields: List<FieldData>): void
        }

        class MethodData {
            - name: String
            - descriptor: String
            - accessFlags: int
            - returnType: String
            - parameterTypes: List<String>
            - instructions: List<InstructionData>
            - calledMethods: List<MethodReference>
            + MethodData(name: String, descriptor: String, accessFlags: int, returnType: String, parameterTypes: List<String>)
            + getName(): String
            + getDescriptor(): String
            + isPrivate(): boolean
            + isPublic(): boolean
            + isStatic(): boolean
            + isConstructor(): boolean
            + getReturnType(): String
            + getParameterTypes(): List<String>
            + getParameterCount(): int
            + getCalledMethods(): List<MethodReference>
            + addCalledMethod(methodRef: MethodReference): void
            + getInstructions(): List<InstructionData>
            + addInstruction(instruction: InstructionData): void
        }

        class FieldData {
            - name: String
            - descriptor: String
            - accessFlags: int
            + FieldData(name: String, descriptor: String, accessFlags: int)
            + getName(): String
            + getDescriptor(): String
            + isPublic(): boolean
            + isPrivate(): boolean
            + isFinal(): boolean
            + isStatic(): boolean
        }

        class MethodReference {
            - owner: String
            - name: String
            - descriptor: String
            + MethodReference(owner: String, name: String, descriptor: String)
            + getOwner(): String
            + getName(): String
            + getDescriptor(): String
            + matches(method: MethodData): boolean
        }

        class InstructionData {
            - opcode: int
            - textRepresentation: String
            + InstructionData(opcode: int, textRepresentation: String)
            + getOpcode(): int
            + getTextRepresentation(): String
        }
    }
}

package "Datasource Layer" {

    abstract class LLMService {
        # apiKey: String
        # baseUrl: String
        # timeout: int
        + LLMService(apiKey: String)
        + {abstract} getResponse(prompt: String): String
        + {abstract} getProviderName(): String
        + isAvailable(): boolean
        # handleError(e: Exception): String
    }

    enum LLMProviderType {
        OPENAI
    }

    class OpenAILLMService {
        - client: OpenAIClient
        + OpenAILLMService(apiKey: String)
        + getResponse(prompt: String): String
        + getProviderName(): String
        - extractTextFromResponse(response: Response): String
    }

    class ClassAnalyzer {
        + analyzeFromPaths(filePaths: List<String>): List<ClassData>
        + analyzeFromNames(classNames: List<String>): List<ClassData>
        - parseClassNode(classNode: ClassNode): ClassData
        - parseMethod(methodNode: MethodNode): MethodData
        - parseField(fieldNode: FieldNode): FieldData
    }

    class DependencyGraph {
        - {static} instance: DependencyGraph
        - graph: Map<String, Set<String>>
        - DependencyGraph()
        + {static} getInstance(): DependencyGraph
        + addDependency(from: String, to: String): void
        + getDependencies(className: String): Set<String>
        + collectDependencies(classData: ClassData): void
        + findCycles(): List<List<String>>
        - dfs(node: String, visited: Set<String>, stack: Set<String>, path: LinkedList<String>, cycles: List<List<String>>): void
        - extractCycle(path: LinkedList<String>, start: String): List<String>
        + isConcreteClass(internalName: String): boolean
        + isUserDefinedClass(internalName: String): boolean
        - isLibraryClass(internalName: String): boolean
        - isInterface(internalName: String): boolean
        - isAbstractClass(internalName: String): boolean
        - isEnum(internalName: String): boolean
        - addDependencyFromDescriptor(from: String, descriptor: String): void
        + clear(): void
    }

    enum ClassInputType {
        COMPILED_CLASS_PATH
        FULLY_QUALIFIED_NAME
    }
}

' Presentation Layer Relationships
Application --> UserInterface
Application --> Linter
Application ..> CheckType
Application ..> LLMServiceFactory
Application ..> LLMProviderType
Application ..> LLMService
Application ..> ClassInputType
Application ..> CLIUserInterface
Application ..> LintResultObserver

CLIUserInterface ..|> UserInterface
CLIUserInterface ..|> LintResultObserver
CLIUserInterface ..> LintResult
CLIUserInterface ..> CheckType
CLIUserInterface ..> LLMProviderType
CLIUserInterface ..> ClassInputType

UserInterface ..> ClassInputType
UserInterface ..> CheckType
UserInterface ..> LLMProviderType

' Domain Layer Relationships
Linter --> ClassAnalyzer
Linter --> DependencyGraph
Linter --> LintResultObserver
Linter --> LLMService
Linter ..> CheckType
Linter ..> ClassData
Linter ..> CircularDependencyCheck
Linter ..> LintCheck
Linter ..> LintResult
Linter ..> Severity
Linter ..> TooManyArgumentsCheck
Linter ..> PublicNonFinalFieldCheck
Linter ..> UnusedPrivateMethodCheck
Linter ..> MethodNameAppropriatenessCheck
Linter ..> ConcreteDependencyCheck

LLMServiceFactory ..> LLMService
LLMServiceFactory ..> LLMProviderType
LLMServiceFactory ..> OpenAILLMService

LintCheck ..> CheckType
LintCheck ..> ClassData
LintCheck ..> LintResult
LintCheck ..> Severity

TooManyArgumentsCheck --|> LintCheck
TooManyArgumentsCheck ..> MethodData

PublicNonFinalFieldCheck --|> LintCheck
PublicNonFinalFieldCheck ..> FieldData

UnusedPrivateMethodCheck --|> LintCheck
UnusedPrivateMethodCheck ..> MethodData
UnusedPrivateMethodCheck ..> MethodReference

MethodNameAppropriatenessCheck --|> LintCheck
MethodNameAppropriatenessCheck --> LLMService
MethodNameAppropriatenessCheck ..> MethodData
MethodNameAppropriatenessCheck ..> InstructionData

CircularDependencyCheck --|> LintCheck
CircularDependencyCheck --> DependencyGraph

ConcreteDependencyCheck --|> LintCheck
ConcreteDependencyCheck --> DependencyGraph

LintResultObserver ..> LintResult

LintResult --> Severity

ClassData --> MethodData
ClassData --> FieldData

MethodData --> MethodReference
MethodData --> InstructionData

MethodReference ..> MethodData

' Datasource Layer Relationships
OpenAILLMService --|> LLMService

ClassAnalyzer ..> ClassData
ClassAnalyzer ..> MethodData
ClassAnalyzer ..> FieldData
ClassAnalyzer ..> InstructionData
ClassAnalyzer ..> MethodReference

DependencyGraph ..> ClassData
DependencyGraph ..> FieldData
DependencyGraph ..> MethodData
DependencyGraph ..> MethodReference

@enduml
